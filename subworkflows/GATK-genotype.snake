if "subw_outputs_dict" in locals() and "ids" in locals():
    recal = expand(paths['snp_tranche'], chromosome=chromosomes)
    if all([os.path.exists(f) for f in recal]):
        subw_outputs_dict['GATK-genotype'] = expand(paths['indel_vcf'],
            chromosome=chromosomes)
    else:
        subw_outputs_dict['GATK-genotype'] = recal

rule chrom_split:
    input:
        bam=paths['recal_bam']

    output:
        paths['recal_chroms_bam']

    params:
        chrom=lambda wc: f'{wc.chromosome}'

    singularity:
        paths['gatk-container']

    group:
        'chrom_split_group'

    shell:
        'samtools view -hb {input.bam} {params.chrom} > {output}'

rule group_chrom_split:
    input:
        ancient(expand(
            paths['recal_chroms_bam'].replace('{id}', '{{id}}'),
            chromosome=chromosomes))

    output:
        temp(touch(paths['split_temp']))

    group:
        'chrom_split_group'

    # note the input from scrubbing is read multiple times, hence the *len
    resources:
        time=lambda wildcards, input, attempt: est_resource(
                'chrom_split', [paths['recal_bam'].format(id=wildcards.id)]*len(input),
                'time', 2000, attempt),
        mem=500,
        short_jobs=lambda wildcards, input, attempt: est_resource(
                'chrom_split', [paths['recal_bam'].format(id=wildcards.id)]*len(input),
                'short_jobs', 0, attempt),

rule index_bam:
    input:
        bam=ancient("{dir}/{id}.chr{chromosome}.bam"),
        split=ancient(paths['split_temp'])

    output: "{dir}/{id}.chr{chromosome}.bam.bai"

    singularity: "docker://biocontainers/samtools:v1.9-4-deb_cv1"

    resources:
        mem=lambda wildcards, input, attempt: est_resource(
            'index_bam', input, 'mem', 4000, attempt),
        time=lambda wildcards, input, attempt: est_resource(
            'index_bam', input, 'time', 180, attempt),
        short_jobs=lambda wildcards, input, attempt: est_resource(
            'index_bam', input, 'short_jobs', 0, attempt),

    shell:
        'samtools sort '
            '-m $(({resources.mem} * 8 / 10))M '
            '-o {input.bam}.sort.bam '
            '{input.bam}\n'
        'mv {input.bam}.sort.bam {input.bam} \n'
        'samtools index {input.bam} {output} '


rule haplotype_caller:
    input:
        bam=ancient(paths['recal_chroms_bam']),
        bai=ancient(paths['recal_chroms_bai']),

    output:
        vcf=paths['haplotype_raw'],
        idx=paths['haplotype_idx']

    resources:
        mem=lambda wildcards, input, attempt: est_resource(
                'haplotype', input, 'mem', 8000, attempt),
        time=lambda wildcards, input, attempt: est_resource(
                'haplotype', input, 'time', 900, attempt),
        short_jobs=lambda wildcards, input, attempt: est_resource(
                'haplotype', input, 'short_jobs', 0, attempt),

    singularity:
        paths['gatk-container']

    shell:
        'gatk --java-options -Xmx$(({resources.mem} * 8 / 10))M '
            'HaplotypeCaller  '
            '--verbosity {config[gatk][verbosity]} '
            '-R {paths[ref_genome]} '
            '-I {input.bam} '
            '-O {output.vcf} '
            '{config[gatk][HaplotypeCaller][options]}'

rule name_map:
    input:
        vcf=lambda wildcards: expand(paths['haplotype_raw']\
                                     .replace('{chromosome}', \
                                              wildcards.chromosome),
                                     id=ids),
        idx=lambda wildcards: expand(paths['haplotype_idx']\
                                     .replace('{chromosome}', \
                                              wildcards.chromosome),
                                     id=ids)

    output:
        temp(paths['name_map'])

    group: 'db_import'

    run:
        import glob
        import os
        with open(output[0], 'w') as outfile:
            # get variants in output
            for f in input.vcf:
                sample = os.path.split(f)[1]
                sample = sample[:sample.find('.')]  # remove after first _
                outfile.write(
                    "{}\t{}\n".format(
                        sample,
                        f))

            # get variants in 1000 genomes
            supp_dir = paths['1000G_dir'].format(
                    chromosome=wildcards.chromosome)

            if glob.glob(supp_dir + "/*.g.vcf") == []:
                raise ValueError(f'Supplemental files not found in {supp_dir}')

            for f in glob.glob(supp_dir + "/*.g.vcf"):
                sample = os.path.split(f)[1]
                sample = sample[:sample.find('_')]  # remove after first _
                outfile.write(
                    "{}\t{}\n".format(
                        sample,
                        f))

rule db_import:
    input:
        paths['name_map']

    output:
        temp(directory(paths['genomics_db']))

    singularity:
        paths['gatk-container']

    group: 'db_import'

    resources:
        time=3*24*60,
        mem=16000

    shell:
        'gatk --java-options -Xmx$(({resources.mem} * 8 / 10))M '
            'GenomicsDBImport  '
            '--verbosity {config[gatk][verbosity]} '
            '-L {wildcards.chromosome} '
            '--sample-name-map {input} '
            '--genomicsdb-workspace-path {output} '
            '{config[gatk][GenomicsDBImport][options]} '

rule genotype_gvcf:
    input:
        db=paths['genomics_db'],

    output:
        vcf=paths['genotype_vcf'],
        tbi=paths['genotype_tbi']

    params:
        interval=lambda wildcards: f'{wildcards.chromosome}'

    singularity:
        paths['gatk-container']

    resources:
        time=6*24*60,
        mem=8000

    shell:
        'gatk --java-options -Xmx$(({resources.mem} * 5 / 10))M '
            'GenotypeGVCFs '
            '--verbosity {config[gatk][verbosity]} '
            '-R {paths[ref_genome]} '
            '-L {params.interval} '
            '--variant gendb://{input.db} '
            '-O {output.vcf} '
            '{config[gatk][GenotypeGVCFs][options]} '
            '2>/dev/null'

def get_snp_options(wildcards):
    return config['gatk']['VariantRecalibrator']['options'].format(
            hapmap=paths['ref_hapmap'],
            omni=paths['ref_omni'],
            OKG=paths['ref_1000g'],
            dbsnp=paths['ref_dbsnp'])

rule variant_recal_snp:
    input:
        ref=paths['ref_genome'],
        vcf=paths['genotype_vcf'],
        tbi=paths['genotype_tbi']

    output:
        recal=paths['snp_recal'],
        tranche=paths['snp_tranche'],
        rscript=paths['snp_script']

    params:
        get_snp_options

    singularity:
        paths['gatk-container']

    resources:
        time=120,
        mem=2000

    shell:
        'gatk --java-options -Xmx$(({resources.mem} * 8 / 10))M '
            'VariantRecalibrator '
            '--verbosity {config[gatk][verbosity]} '
            '-R {input.ref} '
            '-V {input.vcf} '
            '--output {output.recal} '
            '--tranches-file {output.tranche} '
            '--rscript-file {output.rscript} '
            '{params}'

rule apply_vqsr_snp:
    input:
        ref=paths['ref_genome'],
        vcf=paths['genotype_vcf'],
        tbi=paths['genotype_tbi'],
        recal=paths['snp_recal'],
        tranche=paths['snp_tranche'],

    output:
        vcf=paths['snp_vcf']

    singularity:
        paths['gatk-container']

    resources:
        time=62,
        mem=2000

    shell:
        'gatk --java-options -Xmx$(({resources.mem} * 8 / 10))M '
            'ApplyVQSR '
            '--verbosity {config[gatk][verbosity]} '
            '-R {input.ref} '
            '--tranches-file {input.tranche} '
            '--recal-file {input.recal} '
            '-V {input.vcf} '
            '-O {output.vcf} '
            '{config[gatk][ApplyVQSR][options]}'

def get_indel_options(wildcards):
    return config['gatk']['VariantRecalibratorIndel']['options'].format(
            mills=paths['ref_mills'],
            dbsnp=paths['ref_dbsnp'])

rule variant_recal_indel:
    input:
        ref=paths['ref_genome'],
        vcf=paths['snp_vcf'],

    output:
        recal=paths['indel_recal'],
        tranche=paths['indel_tranche'],
        rscript=paths['indel_script']

    params:
        get_indel_options

    singularity:
        paths['gatk-container']

    resources:
        time=120,
        mem=2000

    shell:
        'gatk --java-options -Xmx$(({resources.mem} * 8 / 10))M '
            'VariantRecalibrator '
            '--verbosity {config[gatk][verbosity]} '
            '-R {input.ref} '
            '-V {input.vcf} '
            '--output {output.recal} '
            '--tranches-file {output.tranche} '
            '--rscript-file {output.rscript} '
            '{params}'

rule apply_vqsr_indel:
    input:
        ref=paths['ref_genome'],
        vcf=paths['snp_vcf'],
        recal=paths['indel_recal'],
        tranche=paths['indel_tranche'],

    output:
        vcf=paths['indel_vcf']

    singularity:
        paths['gatk-container']

    resources:
        time=62,
        mem=2000

    shell:
        'gatk --java-options -Xmx$(({resources.mem} * 8 / 10))M '
            'ApplyVQSR '
            '--verbosity {config[gatk][verbosity]} '
            '-R {input.ref} '
            '--tranches-file {input.tranche} '
            '--recal-file {input.recal} '
            '-V {input.vcf} '
            '-O {output.vcf} '
            '{config[gatk][ApplyVQSRIndel][options]}'
